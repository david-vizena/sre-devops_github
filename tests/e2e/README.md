# End-to-End Testing

This directory contains end-to-end testing scripts and documentation for the portfolio project.

## Overview

End-to-end tests verify that all components of the application stack work together correctly:
- Kubernetes deployments and services
- Service-to-service communication
- Ingress and external access
- Observability stack (Prometheus, Grafana, Jaeger)
- Vault integration
- Full user flows

## Running Tests

### Prerequisites

1. `kubectl` configured to access your AKS cluster
2. All services deployed to the cluster
3. Ingress controller configured (or use port-forward)

### Basic Test Run

```bash
# Set namespaces (optional, defaults shown)
export NAMESPACE="default"
export DATA_NAMESPACE="data-services"
export MONITORING_NAMESPACE="monitoring"

# Run the test script
./tests/e2e/e2e-test.sh
```

### Testing via Ingress

If you have an ingress IP configured:

```bash
export INGRESS_IP="your.ingress.ip"
./tests/e2e/e2e-test.sh
```

### Testing via Port-Forward

If ingress is not available, you can use port-forward:

```bash
# Terminal 1: Port-forward API Gateway
kubectl port-forward svc/js-gateway 8082:8080 -n default

# Terminal 2: Port-forward React Frontend
kubectl port-forward svc/react-frontend 3000:80 -n default

# Terminal 3: Run tests
export INGRESS_IP="localhost:8082"
./tests/e2e/e2e-test.sh
```

## What the Tests Cover

### 1. Kubernetes Resources
- Verifies all deployments, services, and ingress resources exist
- Checks resource status in correct namespaces

### 2. Pod Status
- Verifies all pods are running and ready
- Checks pod health across all services

### 3. Health Check Endpoints
- Tests `/health` endpoints for all services
- Verifies services respond correctly via ingress or port-forward

### 4. Service-to-Service Communication
- Tests internal Kubernetes service DNS resolution
- Verifies services can communicate with each other

### 5. Observability Stack
- Checks Prometheus, Grafana, and Jaeger are accessible
- Verifies health endpoints for monitoring services

### 6. Vault Integration
- Checks Vault pod is running
- Verifies Vault is initialized and accessible

## Manual Testing Checklist

Beyond automated tests, manually verify:

- [ ] Frontend loads and displays correctly
- [ ] Can submit a transaction via frontend
- [ ] Transaction is processed by Go service
- [ ] Analytics are generated by Python service
- [ ] Auth service works (register/login)
- [ ] Prometheus is scraping metrics
- [ ] Grafana dashboards show data
- [ ] Jaeger traces appear for requests
- [ ] Vault secrets are accessible to services
- [ ] CI/CD pipeline works (push to main triggers deployment)

## Troubleshooting

### Services not found
- Ensure services are deployed: `kubectl get deployments -A`
- Check namespace configuration matches your deployment

### Pods not ready
- Check pod logs: `kubectl logs <pod-name> -n <namespace>`
- Verify resource requests/limits are appropriate
- Check for image pull errors

### Ingress not working
- Verify ingress controller is installed
- Check ingress resource: `kubectl get ingress -A`
- Verify external IP is assigned

### Service-to-service communication fails
- Check service DNS: `kubectl exec <pod> -- nslookup <service-name>`
- Verify NetworkPolicies allow communication
- Check service endpoints: `kubectl get endpoints -n <namespace>`

## Next Steps

After basic end-to-end tests pass:
1. Test full user flows (frontend → backend → database)
2. Test error scenarios (service failures, network issues)
3. Test observability (traces, metrics, logs)
4. Test security (auth, secrets, network policies)
5. Test scalability (load testing)

